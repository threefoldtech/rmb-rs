@startuml RMB

participant "Local Process" as lps
database "Local Redis" as lredis
participant "Rmb Peer" as lpeer

participant "Rmb rely" as rely
participant "Rmb rely" as rely2

participant "Rmb Peer" as rpeer
database "Remote Redis" as rredis
participant "Remote Process" as rps

lpeer --> rely: establish websocket connection
rpeer --> rely2: establish websocket connection
...
lps -> lredis: PUSH message on \n(msgbus.system.local)
lredis -> lpeer : POP message from \n(msgbus.system.local)

alt $dst == local
lpeer -> lredis: PUSH msg to (msgbus.$cmd)
else $dst != local
lpeer -> lredis: SET backlog.$id AND ttl to $exp
lpeer -> lredis: for each $dst PUSH $id:$dst to \n(msgbus.system.forward)
end
...
lredis -> lpeer: POP $id from \n(msgbus.system.forward)
lpeer -> rely: message pushed over the websocket to the rely

alt $dst twin managed by same rely
rely -> rely: message is pushed directly to \nreceiver message queue
else
rely --> rely2: message forwarded to destination \nrely over HTTP(s)
end

alt $dst is not managed by this rely
rely2 -> rely: invalid destination error\n(code 400 Bad Request)
else
rely2 -> rely2: message is pushed directly to \nreceiver message queue
end
...
rely2 -> rpeer: message is sent over the \nestablished web socket connection
rpeer -> rredis: push message to (msgbus.$cmd) queue

rredis -> rps: POP from (msgbus.$cmd) queue
rps -> rps: Process and handle message
rps -> rredis: PUSH to $ret
note right
$ret is already set to msgbus.system.reply
by http handler.
It also set $now and swap $dst and $src
end note
...
rredis -> rpeer: POP message from \n(msgbus.system.reply)
rpeer -> rely2: Push message over already \nestablished ws connection
note left
Once received it's up to the rely to forward
the response back to the destination rely
as above.
end note
...
rely -> lpeer: receive messages over established connection
note left
rmb peer can tell the difference between a request
message or a response message hence pushed to proper queue
it can tell that from the protocol message types
end note
lpeer -> lredis: GET message backlog.$id
alt does not exist
lpeer -> lpeer: drop message it probably timedout
else
lpeer -> lredis: PUSH response to $ret from the backlog
end
lredis -> lps: POP response from $ret
@enduml
