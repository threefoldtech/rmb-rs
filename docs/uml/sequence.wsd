@startuml RMB

participant "Local Process" as lp
database "Local Redis" as lr
participant "local Rmb" as lrmb

participant "Remote Rmb" as rrmb
database "Remote Redis" as rr
participant "Remote Process" as rp

lp -> lr: PUSH message on \n(msgbus.system.local)
lr -> lrmb : POP message from \n(msgbus.system.local)

alt $dst == local
lrmb -> lr: PUSH msg to (msgbus.$cmd)
else $dst != local
lrmb -> lr: SET backlog.$id AND ttl to $exp
lrmb -> lr: for each $dst PUSH $id:$dst to \n(msgbus.system.forward)
end
...
lr -> lrmb: POP $id from \n(msgbus.system.forward)
lrmb -> rrmb: POST message to /rmb-remote
note left
 this will allow the module that sends requests
 to run multiple workers each worker can then retry
 multiple time before it succeed or fail
end note
alt $dst != local
rrmb -> lrmb: invalid destination error\n(code 400 Bad Request)
else
rrmb -> rr: PUSH to msgbus.$cmd
note right
$ret is set to msgbus.system.reply
before pushing to the msgbus.$cmd queue
end note
end
...
rr -> rp: POP from (msgbus.$cmd) queue
rp -> rp: Process and handle message
rp -> rr: PUSH to $ret
note right
$ret is already set to msgbus.system.reply
by http handler.
It also set $now and swap $dst and $src
end note
...
rr -> rrmb: POP message from \n(msgbus.system.reply)
rrmb -> lrmb: POST message to /rmb-reply
note left
if recieved message $dst does not
match local id, message is dropped.
end note
lrmb -> lr: GET message backlog.$id
alt does not exist
lrmb -> lrmb: drop message it probably timedout
else
lrmb -> lr: PUSH response to $ret from the backlog
end
lr -> lp: POP response from $ret
@enduml
